MVC Components

The DispatcherServlet looks for implementations of type: 
	HandlerMapping, 
	HandlerAdapter,
	ViewResolver, and 
	HandlerExceptionResolver
	
default configuration can be found in the DispatcherServlet.properties!

----------------------------------------------------------------------------------------------------------------------------------
# Default implementation classes for DispatcherServlet's strategy interfaces.
# Used as fallback when no matching beans are found in the DispatcherServlet context.
# Not meant to be customized by application developers.

HandlerMapping=
	org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\															->ACTIVADO
	org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping (Deprecated) -> RequestMappingHandlerMapping	->ACTIVADO
	org.springframework.web.servlet.handler.SimpleUrlHandlerMapping																->TAMBIEN ACTIVADO (x3)
	
HandlerAdapter=
	org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\																->ACTIVADO
	org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\														->ACTIVADO
	org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter (Deprecated) -> RequestMappingHandlerAdapter	->ACTIVADO
	
ViewResolver=
	org.springframework.web.servlet.view.InternalResourceViewResolver							->ACTIVADO	
	org.springframework.web.servlet.view.ViewResolverComposite									->TAMBIEN ACTIVADO

HandlerExceptionResolver=
	org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\	->NO ACTIVADO
	org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\			->NO ACTIVADO
	org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver					->NO ACTIVADO
	org.springframework.web.servlet.handler.HandlerExceptionResolverComposite					-> EL UNICO ACTIVADO

LocaleResolver= 																				(NINGUNO ACTIVADO BY DEFAULT)
	org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver								->NO ACTIVADO

ThemeResolver=																					(NINGUNO ACTIVADO BY DEFAULT)
	org.springframework.web.servlet.theme.FixedThemeResolver									->NO ACTIVADO

RequestToViewNameTranslator=																	(NINGUNO ACTIVADO BY DEFAULT)
	org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator						->NO ACTIVADO

FlashMapManager=																				(NINGUNO ACTIVADO BY DEFAULT)
	org.springframework.web.servlet.support.SessionFlashMapManager								->NO ACTIVADO
----------------------------------------------------------------------------------------------------------------------------------

The infrastructure beans mentioned earlier can be configured manually, but this is rarely done and is
recommended to be avoided, as the explicit configuration cancels the default configuration for that bean
type. In Spring 4.0, <mvc:annotation-driven/> and the equivalent @EnableWebMvc do just that�override
the default configuration to provide the new features, so you don�t have to struggle with the configuration
yourself.

A Spring web application can use more than one infrastructure bean of a specific type. In this case, the
beans can be chained and have an associated priority value specified using the order property.

HandlerMapping
==============

HandlerAdapter
==============

ViewResolver
=============
http://docs.spring.io/spring/docs/4.1.x/spring-framework-reference/htmlsingle/#mvc-viewresolver

Design pattern named Post-Redirect-Get that prevents duplicate form submissions

Content Type Negotiation
Clients might request different content-types for the same resource via: 
extension, request header, request parameter, and so forth

There are two strategies for a client to request a view from the server:
-Use a distinct URL for each resource by using a different extension in the URL
http://localhost:8080/persons/list.xls requests an Excel view containing a list of persons, while 
http://localhost:8080/persons/list.pdf requests a PDF view containing a list of persons)

-Use the same URL but set the "Accept HTTP request header" to the desired resource type 
(example: a request coming from http://localhost:8080/persons/list
having the Accept header set to application/pdf requests a PDF view containing a list of persons)

The problem with using JavaBeans Activation Framework is that if the extension is not recognized, it sets
the content-type to application/octet-stream by default. This means that the Views configured with the
defaultViews property are not taken into consideration and the ContentNegotiatingViewResolver will return
null. That’s why in Spring 3.2, the useJaf property was introduced; it can be set to false to disable the JavaBeans
Activation Framework. This property has been added to ContentNegotiationManagerFactoryBean too.

CONTINUAR ACA:
http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/ViewResolverRegistry.html#freeMarker--
http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/servlet/config/annotation/ContentNegotiationConfigurer.html
https://spring.io/blog/2013/05/11/content-negotiation-using-spring-mvc
http://www.baeldung.com/2011/10/25/building-a-restful-web-service-with-spring-3-1-and-java-based-configuration-part-2/
http://www.baeldung.com/spring-mvc-content-negotiation-json-xml
https://dzone.com/articles/content-negotiation-using
https://dzone.com/articles/spring-rest-web-service-and

