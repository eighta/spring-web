Spring Web Flow
===============

JavaConf
--------
WebInitializer
AbstractAnnotationConfigDispatcherServletInitializer

WebMvcConfigurerAdapter
-MessageCodesResolver
-Validator

AbstractFlowConfiguration
-ApplicationContext(1)
-ApplicationContext(2)

MvcConfig
-WebFlowConfig
-Validator

WebFlowConfig
-MvcConfig

What are the different parts of a flow

The web flow has three main parts - States, Transition and Data.
States - States are points on the flow where an action happens or decision is made or a view is displayed. The end of a flow is also a state. Sometimes, to increase brewity, a subset of a flow can be combined together to form a sub-flow and then the sub-flow is a state in the main flow.
Transitions - Transition connects two states. A movement of request from one state to another is called a transition.
Data - Data is the information that is carried from one state to another. The life span of the data depends on the scope with which it is declared. 

OJO EN LA DIAPOSITVA DEL CURSO DICE:
-STATES, TRANSITIONS AND ACTIONS

States- There are five kinds of states

    View States - A view state displays information to a user or obtains user input using a form. a model can be passed to bind the elements of the form. The view may be implemented as any view defined in spring mvc. (e.g. JSP)
    	(first state in the file becomes "start state")
    Action States - Action states are where actions are perfomed by the spring beans. The action state transitions to another state. The action states generally have an evaluate property that describes what needs to be done. The evaluate is generally a method of one of the registered spring beans. The evaluate expression is a SpEL. More than one action can be configured in which case the actions will be executed one after the other.
    Decision States: Decision state is where a decision is made. A decision state has two transitions depending on whether the decision evaluates to true or false.
    Subflow States - It may be advantageous to call another flow from one flow to complete some steps. The sub flow returns to the original flow when it is complete. Data may be passed from the calling flow into the subflow and output data from the subflow may be retrieved into the calling flow.
    End States - The end state signifies the end of flow. If the end state is part of a root flow then the execution is ended. However, if its part of a sub flow then the root flow is resumed.

Web Flow Scope
--------------
(Flow Data Scopes) Flow Data can be stored as variables that can be created using the 'var' element or using the evaluate expression.
Variable scope - The lifespan of the variable depends on the scope with which it is declared. 

The scopes available are:
	
	Flow - Available within a flow. Not available in sub flows (HTTP Session) 
	View - Available only during the lifetime of a view. 
			Created when a view is created and destroyed once a view is destroyed (HTTP Session)
	Request - Available during the life of a request in a flow
	Flash - Available during the lifetime of a flow. However, once a state is rendered, the variable is cleared.
			(HTTP Session temporary)
    Conversation - The conversation scope starts when a flow starts and ends when the flow ends. 
    		It is available in sub flows (HTTP Session)

Spring Web Flow allows you to represent the page flows of your application in a clear 
and simple way and the good part is that you can use it Spring Web Flow with other 
frameworks like Struts, Spring and JSF.   
   
Advantages of Spring Web Flow:

    Page flow of the application is visible just by looking at XML or java configuration.
    Web flows are designed to be self contained, and thus are reusable multiple of times.
    The technique to capture the page flow remains the same for all the cases and there are no specialized approaches for particular situations.


How Web Flow Works

When Web Flow receives a transition request
-It is submitted to the same URL as current state
-The flow awakes up
-The next state is determined
-A redirect is issued to the new URL for the new state

Every Web Flow interaction uses "TWO" requests
 Consequence:
  -Data associated with the initial request is not available
	when the next state (view) is generated
  -So Webflow provides flash-scope
  

*Configuring Web Flow

Web Flow provides a Spring XML namespace for configuration
-Use to setup Web Flow inside Spring MVC

Recommendation:
-Define setup using two configuration files
--webflow-config.xml for core Web Flow system
--mvc-config.xml for Spring MVC adapters

*Steps to use within Spring MVC:

1 Configure a flow-registry (and builder-services)
2 Configure the flow-executor
3 Enable flow handling by Spring MVC
4 Setup FlowHandlerMapping (maps registered flows to resource URLs)

*The Flow Registry

-Stores your flow definitions by unique id

-Flows typically stored under /WEB-INF
-Options for registering flows
 >One at a time
 >Using a wildcard pattern
 
-Can be customized with "flow builder services"
 >Specify development mode
 >Specify view technology
 >Specify conversion service (same as MVC)
 
*Registering Flow Definitions

-One at a time
<webflow:flow-registry id="flowRegistry">
	<webflow:flow-location id="flights/checkin" path="/WEB-INF/flights/checkin/checkin.xml" />
</webflow:flow-registry>

-By using a wildcard pattern
 >The derived flow id is relative to the base path
<webflow:flow-registry id="flowRegistry" base-path="/WEB-INF/">
	<webflow:flow-location-pattern value="**/*-flow.xml" />
</webflow:flow-registry>

*Signaling Flow Events
 >/flights/checkin?execution=e1s1&_eventId=update
 
 **with forms
 <input type="submit" value="Next" class="button" name="_eventId_next" />
 
 *lab1
 /rewards/newReward > /persons/newPerson

Evaluation and Variables
------------------------

<evaluate> elements to invoke SpEL
<var> and <set>

<evaluate result="flowScope.itinerary" 
 expression="checkinAgent.findItinerary(passengerInfo)"/>

Spring EL Syntax
-----------------
<variable>[.property]
 
Variable resolution algorithm
-Busca en variables reservadas primero
-Busca en Web Flow Scopes de segundo
-Busca en Flow Application Context de tercero (Spring Beans)

Variables Reservadas SpEL
-------------------------
conversationScope
flowScope
viewScope
requestScope
flashScope
flowExecutionUrl
flowRequestContext
requestParameters
currentEvent
currentUser
externalContext
messageContext
resourceBundle

OJO: sessionScope NO EXISTE, usar: externalContext.sessionMap

Se definen dentro de los tags: <flow> y <view-state>

Actions During Transitions
--------------------------
-Corren antes que ocurra la transition
 >La transition solo ocurre si el <evaluate> return
 	-Boolean.TRUE or true
 	-String= sucess, yes, true
 	-Cualquier tipo o null

Solo un <evaluate> es permitido (WARNING)

<set> nunca detienen la transicion, es posible utilizar muchos

 *lab2

MISC
====
Los ids de los flows, son generados a partir de la carpeta en donde se encuentra el XML (authoring flow)
e.g. : 	/folder1/folder2/folder3/folder4/folder5/folderFlow-flow.xml
id:		"folder1/folder2/folder3/folder4/folder5"

**Los "View States" poseen un id, el cual resuelve a un "View Template", correspondiente al mismo nombre (id)
(por defecto id.jsp), pero obviamente se puede configurar el ViewResolution a travez de los ViewResolvers

**Las Transitions, manejan los eventos de un usuario
<transition on="findItinerary" to="reviewItinerary" />

**Existen las Global Transitions, que pueden ser llamadas desde cualquier view-state
<global-transition on="cancel" to="cancelled" />
NOTA: en el xml, me toco definirlas al final del archivo (de primeras lanzaba error)

**Sending End State Redirects
Use the <end-state> view attribute to specify the URL to redirect to
<end-state id="finish" view="externalRedirect:contextRelative:/flights/checkin/confirm?id=1" />

Can use:
"externalRedirect:" or "flowRedirect:"

Can use:
"servletRelative"		RELACIONADO CON EL SERVLET (frontController de Spring)
"contextRelative",		SE REFIERE AL NIVEL DEL CONTEXTO DEL WEB-APP
"serverRelative",		SOLO FUNCIONA CON:  externalRedirect (FUERA DE LA WEB-APP)

The explicit redirect prefixes supported are:
servletRelative: - redirect to a resource relative to the current servlet
contextRelative: - redirect to a resource relative to the current web application context path
serverRelative: - redirect to a resource relative to the server root
http:// or https:// - redirect to a fully-qualified resource URI

**MVC Flash Scope
Cuando se desea transmitir un dato desde WebFlow a Mvc 

>Se debe habilitar en el FlowHandlerAdapter
<property name="saveOutputToFlashScopeOnRedirect" ref="true"/>

>utilizando el tag: <output name="confirmationNumber" value="1"/>

**To signal an event JSP views use a naming convention for form buttons:
>_eventId_xxx
<button name="_eventId_findItinerary" type="submit">
	Find Itinerary
</button>

>A view can also add _eventId to HTML links
– /flights/checkin?execution=e1s1&_eventId=update

>JSF views specify the event in the action attribute of command buttons and links
<h:commandButton id="findItineraryButton"
	action="findItinerary”
	value="Find Itinerary" />

**Testing Flows
Every flow should have a unit test
– Verifies flow logic works as expected

Web Flow provides JUnit test support
-Extend from a base test class  (AbstractXmlFlowExecutionTests)

Define a new TestCase class per Flow
e.g. FlightCheckinFlowExecutionTests

WebFlow Actions
===============

Scoped Objects
--------------
Flow has a context where objects are stored
-State is managed for you
-Several "data scopes" provided by this context
-Add objects to these scopes during flow execution
-Objects cleaned up when they go out of scope

Explicit variable declaration
– Allocates a scoped object
– Flow and View scope using <var>

Or assign variables dynamically using actions
– Assignment in any scope possible
– See <evaluate> discussed later

WebFlow Scopes
--------------
Flow:			Lasts for the life of the flow
View:			Associated with each view-state
Request: 		Lasts a single request
Flash:			Cleaned up after the next view is rendered
Conversation:	Global execution scope (shared by flow and all subflows)

Flow Variables
--------------
Use <var> tag at "flow level"
-Variable created automatically
-Must have a default or @Autowired constructor
-May have @Autowired property setters too
-The object(s) must be Serializable
-Often used as the data model for views
-Often passed to services invoked by the flow

<var name="concretePerson" class="a8.data.Webmaster" />
<view-state id="enterMainPersonInfo" model="concretePerson">
NOTA: al definir variables en el "Flow Scope", los "view-state" tienen acceso
a estas variables a traves de SpEL en el JSP

Conversation Variables
----------------------
Like flow scope variables
-But available to any sub-flows too
-Similar to global variables: with all the dangers 

Be careful
-Introduces a dependency between flow and sub-flow
-Sub-flows accept input/output parameters: a better option

<evaluate result="conversationScope.itinerary"
	expression="checkinAgent.findItinerary(passengerInfo)"/>
	
View Variables
---------------
Declare using the view-state <var> tag
-Convenient way to allocate a view-scoped object
Created when entering the view-state
-May also be @Autowired with dependencies
Referenced by expressions
-Often used as the data model for a single view
-Often updated over a series of Ajax requests

Nota: Se definen dentro del tag <view-state>, y se puede
utilizar para el atributo: "model" de este mismo tag,
y ademas, puede ser utilizado como parametro a llamadas de metodos
utilizando el tag <evaluate>
<evaluate expression="checkinAgent.findItinerary(passengerInfo)"/>

IMAGEN: RequestScopeVsFlashScope.png
 
FlashScope
----------
Lasts for the entire flow
-But is cleared each time a view renders
Effective scope is:
-Transition from current view to end of "render of next view"
Used to pass data from one state to the next
-Especially request/view scoped data
-Very useful scope

Request Scope
-------------
Two requests per interaction
-First: transition from current state to on-entry of next state
-Second: From on-render of next state to end of render of same state
Typical Usage
-Data needs fetching every time state is redisplayed
--If data can be cached, make it view scoped
-Data needed to initialize next state, but not displayed by it
Generally not that useful (flash scope easier)

Examples
--------
Wherever a variable can be set – its scope can be defined
<set name="flashScope.accountNumber" value="requestParameters.accountNumber"/>
<set name="flashScope.statusMessage" value="'Booking confirmed'"/>
<set name="requestScope.hotelId" value="requestParameters.id"/>

Scope Implementation
--------------------
Conversation, Flow and View scope data are all stored in the user's HTTP session
-After the View has been presented
--The flow then suspends until next transition
-All variables should be Serializable
--Overhead if you store too much data

Flash scope also stored temporarily in session across redirect
-Same considerations: Serializable, overhead

Actions
=======
-Actions execute behavior at specific points within the flow
-Several points where actions can be executed
--on startup, before rendering, on transition, etc

Flow actions often act on Java objects
-Invoke Spring-managed services
-Assign variables

Writing an expression

evaluate
-Evaluate an expression
-Can prevent a transition

set
-Set the value of a variable
-Never prevent a transition, regardless of variable value

Evaluate Action
---------------
-Use <evaluate> to evaluate an expression
-Actions are expressed in EL
-Can use any object in flow context
--Resolve properties on beans in scope
--Invoke methods
-Can also assign result of evaluation
--Save result to a scope
--Optionally perform a result type conversion

<evaluate result="flowScope.itinerary"
	expression="checkinAgent.findItinerary(passengerInfo)" />

Spring EL Syntax
----------------
<variable>[.property]
-Variable resolved against current flow context
-Property can be JavaBeans property or method

Variable resolution "algorithm"
-Search reserved variables first
-Search web flow scopes second
>>request/flash/view/flow/conversation
-Search flow application context third
>>resolve Spring beans

flowScope.foo	[Resolve 'foo' in flow scope]
foo				[Search all scopes looking for 'foo']
foo.bar()		[Invoke method 'bar' on foo]
foo.bar(baz)	[Invoke method bar passing in variable 'baz']

Reserved SpEL Variables
-----------------------
conversationScope
flowScope
viewScope
requestScope
flashScope
flowExecutionUrl
flowRequestContext

requestParameters
currentEvent
currentUser
externalContext
messageContext
resourceBundle

NOTA: Note: sessionScope. Use externalContext.sessionMap

Reserved EL Variables in JSP
----------------------------
Only the following are valid in a JSP page
-Any variables in scope
-requestScope, viewScope , flashScope
-flowExecutionUrl = url of current page
-flowRequestContext = the RequestContext

This is in addition to usual variables
-sessionScope, pageScope, params, ...

For anything else, use flowRequestContext
-flowRequestContext.currentState.id

Examples
--------
<evaluate expression="checkinAgent.update(passengerInfo)" />

<evaluate expression="checkinAgent.findItinerary(passengerInfo)"
	result="flowScope.itinerary" />

<evaluate expression="bookingAgent.countMatches(searchCriteria)"
	result="flowScope.hotelsFound" result-type="long"/>
*El result-type puede ser un string o cualquier tipo primitivo, bigInteger, bigDecimal, 
or fully-qualified class name

Set Action
----------

Assign a new variable in a scope (Must specify a scope, no default)
<set name="flowScope.accountNumber"
	value="requestParameters.accountNumber"/>
	
Update the value of an existing variable
-Or one of its properties
-Scope optional: scope resolution algorithm used
<set name="searchCriteria.sortBy"
	value="requestParameters.sortBy"/>

Places to Invoke Actions From
-----------------------------
-When a flow starts/ends
<flow>
	<on-start>
		<evaluate expression="..."/>
	</on-start>
	
	<on-end>
		<evaluate expression="..."/>
	</on-end>
</flow>


-When a state is entered/exited and rendering/transition

<view-state>
	<on-entry>
		<evaluate expression="..." />
	</on-entry>
	
	<on-render>
		<evaluate expression="..." />
	</on-render>
	
	<transition>
		<evaluate expression="..." />
	</transition>
	
	<on-exit>
		<evaluate expression="..." />
	</on-exit>

</view-state>


Actions During Transitions
--------------------------
Run prior to the transition
Transition will only occur if <evaluate/> returns
-Boolean.TRUE or true
-One of these Strings: "success", "yes", "true"
-Any other type or null
Only one evaluate is allowed 
NOTA: intente colocar varios <evaluate> y lo permite (no se si sea por la ultima version)

-Recall: <set/> never prevents a transition, use as many as you want
<transition on="modify " to="searchForm " >
	<evaluate expression=" ... ">
</transition>

Actions Before Rendering
------------------------
<view-state id="enterPassengerInformation">
	<on-render>
		<evaluate expression="...">
	</on-render>
</view-state>

Executed again on every browser refresh
-contrast to on-entry

Form Handling Views
-------------------
Data binding and validation with Forms
-A common use for views

A view can be associated with a model object
-The form object in MVC

<view-state id="enterPassengerInformation"
	model="passengerInfo" />
	
The model object can be in different scopes

Submitting the Form
-------------------
Automatic data binding + validation

Can be suppressed
<view-state id="enterPassengerInformation" model="passengerInfo">
	<transition on="submit" to="reviewItinerary" />
	<transition on="cancel" to="end"
		bind="false" validate="false"/>
</view-state>

Flow remains in same view on submit failure

Restricting Automatic Binding
-----------------------------
Not all fields should be bound to
-fields which are read but not written by the end-user
-application security can be compromised

Binder white-lists elements eligible for binding
<view-state id="enterDiningInformation" model="diningForm">
	<binder>
		<binding property="amount" required="true" />
		<binding property="creditCardNumber" required="true" />
		...
	</binder>
</view-state>

Customizing Type Conversion
---------------------------
Spring 3 Formatters can also be used for Web Flow
-Same approach as in Spring MVC
Custom formatters defined for Spring MVC are not
automatically defined for Web Flow as well
-Must be explicitly associated using flow builder services
-Default formatters are present in both "out of the box"

<webflow:flow-builder-services
	id="flowBuilderServices" conversion-service="converter"/>
<webflow:flow-registry id="flowRegistry"
	flow-builder-services="flowBuilderServices">

Data Binding Error Messages
---------------------------
Web Flow uses a different strategy for generating
typeMismatch and required error codes
-The error code is appended to the end and not at the beginning

typeMismatch
amount.typeMismatch
diningForm.amount.typeMismatch
common.money.MonetaryAmount.typeMismatch

required
amount.required
diningForm.amount.required
common.money.MonetaryAmount.required

Customizing Data Binding Error Messages
---------------------------------------
To use same error code strategy in WebFlow as MVC,
add a DefaultMessageCodesResolver

<bean id="viewFactoryCreator" class="...MvcViewFactoryCreator">
	<property name="viewResolvers" ref="tilesViewResolver" />
	<property name="messageCodesResolver ref="mcr" />
</bean>

typeMismatch.amount.
typeMismatch.diningForm.amount
typeMismatch.common.money.MonetaryAmount

Validation Options
------------------
JSR 303 validation support
-annotate the form object
-automatically used for validation
-but: you must enable this

Custom validators
-well-known method or class
-automatically invoked

Can use either, both or neither

JSR 303 Validation (Web Flow 2.3)
------------------
Enable same validator as MVC
-via Web Flow builder services

<webflow:flow-builder-services
	id="flowBuilderServices" validator="validationService"/>
<bean id="validationService" class="org.springframework.
	validation.beanvalidation.LocalValidatorFactoryBean"/>

public class AccountSearchCriteria {
	@NotEmpty
	private String searchString = "";
	
	@Min(0) @Max(100)
	private int maximumResults = 10;
}

Validation In Code
------------------
Four Options
-Add a method with specific signature to Model Object (1)

-Create a class with a specific name
 >Add a method whose name relates to the view (2)
 >Define a validate() method taking the Model Object type (3)

-Write your own validator class (4)
 >Invoke a validation method in flow XML

e.g. Having this view
<view-state id="searchForm" model="accountSearchCriteria" >

1. Validation Via Model Object
------------------------------
Method "discovered" by convention
-validate[view-state-id](ValidationContext ctx)

public class AccountSearchCriteria {
	public void validateSearchForm (ValidationContext ctx) {...}
}

2. Custom Validation Class
--------------------------
Separate validator bean "discovered" by convention
-Bean name: [model-object-name]Validator
-Method name validate[view-name]

Looks for bean by name not type
@Component("accountSearchCriteriaValidator")
public class AccountSearchCriteriaValidator {
	public void validateSearchForm
	(AccountSearchCriteria target, ValidationContext ctx) {...}
}

3. Custom Validation Class, Any View
------------------------------------
Generic validator, independent of any view
-Bean name: [model-object-name]Validator
Method must be called validate
 -Called for any view where AccountSearchCriteria is the model object

@Component("accountSearchCriteriaValidator")
public class AccountSearchCriteriaValidator {
	public void validate(AccountSearchCriteria target, ValidationContext ctx) {...}
}

4. Manual Validation via <evaluate>
-----------------------------------
If you don’t like using our conventions

Validate using an <evaluate> action
If validator returns false, transition is prevented

<view-state id="enterBooking" model="booking">
	<transition on="submit" to="confirmBooking">
		<evaluate expression="bookingValidator.check(booking, messageContext)"/>
	</transition>
</view-state>

public class BookingValidator {
	public boolean check(Booking booking,MessageContext ctx) {...}
}

Registering Errors
------------------
Using an Errors object
-commonly used in Spring MVC

errors.rejectValue("creditCardNumber","creditCard.invalidNumber",
	"A credit card number must have 16 digits.");
	
or

Using a ValidationContext
addMessage(new MessageBuilder().error()
	.source("creditCardNumber")
	.code("creditCard.invalidNumber")
	.defaultText("A credit ... 16 digits.").build());	
	







PROBAR DESDE LA LINEA #540

SLIDE: 888

>>>TODO testear los ConversionService en WebFlow slide 874<<<

>>>INDAGAR LOS SIGUIENTES TAGS<<<
'{
"http://www.springframework.org/schema/webflow":action-state, 
"http://www.springframework.org/schema/webflow":decision-state, 
"http://www.springframework.org/schema/webflow":subflow-state, 
"http://www.springframework.org/schema/webflow":output, 
"http://www.springframework.org/schema/webflow":exception-handler, 
"http://www.springframework.org/schema/webflow":bean-import}'

[DOCUMENTATION]
http://docs.spring.io/spring-webflow/docs/current/reference/htmlsingle/
http://docs.spring.io/spring-webflow/docs/current/reference/html/defining-flows.html [DONE]
http://docs.spring.io/spring-webflow/docs/current/reference/html/el.html
https://www.adictosaltrabajo.com/tutoriales/primerospasos-spring-web-flow-2/