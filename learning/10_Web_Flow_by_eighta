Spring Web Flow
===============

JavaConf
--------
WebInitializer
AbstractAnnotationConfigDispatcherServletInitializer

WebMvcConfigurerAdapter
-MessageCodesResolver
-Validator

AbstractFlowConfiguration
-ApplicationContext(1)
-ApplicationContext(2)

MvcConfig
-WebFlowConfig
-Validator

WebFlowConfig
-MvcConfig

What are the different parts of a flow

The web flow has three main parts - States, Transition and Data.
States - States are points on the flow where an action happens or decision is made or a view is displayed. The end of a flow is also a state. Sometimes, to increase brewity, a subset of a flow can be combined together to form a sub-flow and then the sub-flow is a state in the main flow.
Transitions - Transition connects two states. A movement of request from one state to another is called a transition.
Data - Data is the information that is carried from one state to another. The life span of the data depends on the scope with which it is declared. 

OJO EN LA DIAPOSITVA DEL CURSO DICE:
-STATES, TRANSITIONS AND ACTIONS

States- There are five kinds of states

    View States - A view state displays information to a user or obtains user input using a form. a model can be passed to bind the elements of the form. The view may be implemented as any view defined in spring mvc. (e.g. JSP)
    	(first state in the file becomes "start state")
    Action States - Action states are where actions are perfomed by the spring beans. The action state transitions to another state. The action states generally have an evaluate property that describes what needs to be done. The evaluate is generally a method of one of the registered spring beans. The evaluate expression is a SpEL. More than one action can be configured in which case the actions will be executed one after the other.
    Decision States: Decision state is where a decision is made. A decision state has two transitions depending on whether the decision evaluates to true or false.
    Subflow States - It may be advantageous to call another flow from one flow to complete some steps. The sub flow returns to the original flow when it is complete. Data may be passed from the calling flow into the subflow and output data from the subflow may be retrieved into the calling flow.
    End States - The end state signifies the end of flow. If the end state is part of a root flow then the execution is ended. However, if its part of a sub flow then the root flow is resumed.

Web Flow Scope
--------------
(Flow Data Scopes) Flow Data can be stored as variables that can be created using the 'var' element or using the evaluate expression.
Variable scope - The lifespan of the variable depends on the scope with which it is declared. 

The scopes available are:
	
	Flow - Available within a flow. Not available in sub flows (HTTP Session) 
	View - Available only during the lifetime of a view. 
			Created when a view is created and destroyed once a view is destroyed (HTTP Session)
	Request - Available during the life of a request in a flow
	Flash - Available during the lifetime of a flow. However, once a state is rendered, the variable is cleared.
			(HTTP Session temporary)
    Conversation - The conversation scope starts when a flow starts and ends when the flow ends. 
    		It is available in sub flows (HTTP Session)

Spring Web Flow allows you to represent the page flows of your application in a clear 
and simple way and the good part is that you can use it Spring Web Flow with other 
frameworks like Struts, Spring and JSF.   
   
Advantages of Spring Web Flow:

    Page flow of the application is visible just by looking at XML or java configuration.
    Web flows are designed to be self contained, and thus are reusable multiple of times.
    The technique to capture the page flow remains the same for all the cases and there are no specialized approaches for particular situations.


How Web Flow Works

When Web Flow receives a transition request
-It is submitted to the same URL as current state
-The flow awakes up
-The next state is determined
-A redirect is issued to the new URL for the new state

Every Web Flow interaction uses "TWO" requests
 Consequence:
  -Data associated with the initial request is not available
	when the next state (view) is generated
  -So Webflow provides flash-scope
  

*Configuring Web Flow

Web Flow provides a Spring XML namespace for configuration
-Use to setup Web Flow inside Spring MVC

Recommendation:
-Define setup using two configuration files
--webflow-config.xml for core Web Flow system
--mvc-config.xml for Spring MVC adapters

*Steps to use within Spring MVC:

1 Configure a flow-registry (and builder-services)
2 Configure the flow-executor
3 Enable flow handling by Spring MVC
4 Setup FlowHandlerMapping (maps registered flows to resource URLs)

*The Flow Registry

-Stores your flow definitions by unique id

-Flows typically stored under /WEB-INF
-Options for registering flows
 >One at a time
 >Using a wildcard pattern
 
-Can be customized with "flow builder services"
 >Specify development mode
 >Specify view technology
 >Specify conversion service (same as MVC)
 
*Registering Flow Definitions

-One at a time
<webflow:flow-registry id="flowRegistry">
	<webflow:flow-location id="flights/checkin" path="/WEB-INF/flights/checkin/checkin.xml" />
</webflow:flow-registry>

-By using a wildcard pattern
 >The derived flow id is relative to the base path
<webflow:flow-registry id="flowRegistry" base-path="/WEB-INF/">
	<webflow:flow-location-pattern value="**/*-flow.xml" />
</webflow:flow-registry>

*Signaling Flow Events
 >/flights/checkin?execution=e1s1&_eventId=update
 
 **with forms
 <input type="submit" value="Next" class="button" name="_eventId_next" />
 
 *lab1
 /rewards/newReward > /persons/newPerson

Evaluation and Variables
------------------------

<evaluate> elements to invoke SpEL
<var> and <set>

<evaluate result="flowScope.itinerary" 
 expression="checkinAgent.findItinerary(passengerInfo)"/>

Spring EL Syntax
-----------------
<variable>[.property]
 
Variable resolution algorithm
-Busca en variables reservadas primero
-Busca en Web Flow Scopes de segundo
-Busca en Flow Application Context de tercero (Spring Beans)

Variables Reservadas SpEL
-------------------------
conversationScope
flowScope
viewScope
requestScope
flashScope
flowExecutionUrl
flowRequestContext
requestParameters
currentEvent
currentUser
externalContext
messageContext
resourceBundle

OJO: sessionScope NO EXISTE, usar: externalContext.sessionMap

Se definen dentro de los tags: <flow> y <view-state>

Actions During Transitions
--------------------------
-Corren antes que ocurra la transition
 >La transition solo ocurre si el <evaluate> return
 	-Boolean.TRUE or true
 	-String= sucess, yes, true
 	-Cualquier tipo o null

Solo un <evaluate> es permitido (WARNING)

<set> nunca detienen la transicion, es posible utilizar muchos

 *lab2

MISC
====
Los ids de los flows, son generados a partir de la carpeta en donde se encuentra el XML (authoring flow)
e.g. : 	/folder1/folder2/folder3/folder4/folder5/folderFlow-flow.xml
id:		"folder1/folder2/folder3/folder4/folder5"

**Los "View States" poseen un id, el cual resuelve a un "View Template", correspondiente al mismo nombre (id)
(por defecto id.jsp), pero obviamente se puede configurar el ViewResolution a travez de los ViewResolvers

**Las Transitions, manejan los eventos de un usuario
<transition on="findItinerary" to="reviewItinerary" />

**Existen las Global Transitions, que pueden ser llamadas desde cualquier view-state
<global-transition on="cancel" to="cancelled" />
NOTA: en el xml, me toco definirlas al final del archivo (de primeras lanzaba error)

**Sending End State Redirects
Use the <end-state> view attribute to specify the URL to redirect to
<end-state id="finish" view="externalRedirect:contextRelative:/flights/checkin/confirm?id=1" />

Can use:
"externalRedirect:" or "flowRedirect:"

Can use:
"servletRelative"		RELACIONADO CON EL SERVLET (frontController de Spring)
"contextRelative",		SE REFIERE AL NIVEL DEL CONTEXTO DEL WEB-APP
"serverRelative",		SOLO FUNCIONA CON:  externalRedirect (FUERA DE LA WEB-APP)

The explicit redirect prefixes supported are:
servletRelative: - redirect to a resource relative to the current servlet
contextRelative: - redirect to a resource relative to the current web application context path
serverRelative: - redirect to a resource relative to the server root
http:// or https:// - redirect to a fully-qualified resource URI

**MVC Flash Scope
Cuando se desea transmitir un dato desde WebFlow a Mvc 

>Se debe habilitar en el FlowHandlerAdapter
<property name="saveOutputToFlashScopeOnRedirect" ref="true"/>

>utilizando el tag: <output name="confirmationNumber" value="1"/>

**To signal an event JSP views use a naming convention for form buttons:
>_eventId_xxx
<button name="_eventId_findItinerary" type="submit">
	Find Itinerary
</button>

>A view can also add _eventId to HTML links
– /flights/checkin?execution=e1s1&_eventId=update

>JSF views specify the event in the action attribute of command buttons and links
<h:commandButton id="findItineraryButton"
	action="findItinerary”
	value="Find Itinerary" />

**Testing Flows
Every flow should have a unit test
– Verifies flow logic works as expected

Web Flow provides JUnit test support
-Extend from a base test class  (AbstractXmlFlowExecutionTests)

Define a new TestCase class per Flow
e.g. FlightCheckinFlowExecutionTests

WebFlow Actions
===============

Scoped Objects
--------------
Flow has a context where objects are stored
-State is managed for you
-Several "data scopes" provided by this context
-Add objects to these scopes during flow execution
-Objects cleaned up when they go out of scope

Explicit variable declaration
– Allocates a scoped object
– Flow and View scope using <var>

Or assign variables dynamically using actions
– Assignment in any scope possible
– See <evaluate> discussed later

WebFlow Scopes
--------------
Flow:			Lasts for the life of the flow
View:			Associated with each view-state
Request: 		Lasts a single request
Flash:			Cleaned up after the next view is rendered
Conversation:	Global execution scope (shared by flow and all subflows)

Flow Variables
--------------
Use <var> tag at "flow level"
-Variable created automatically
-Must have a default or @Autowired constructor
-May have @Autowired property setters too
-The object(s) must be Serializable
-Often used as the data model for views
-Often passed to services invoked by the flow

<var name="concretePerson" class="a8.data.Webmaster" />
<view-state id="enterMainPersonInfo" model="concretePerson">
NOTA: al definir variables en el "Flow Scope", los "view-state" tienen acceso
a estas variables a traves de SpEL en el JSP

Conversation Variables
----------------------
Like flow scope variables
-But available to any sub-flows too
-Similar to global variables: with all the dangers 

Be careful
-Introduces a dependency between flow and sub-flow
-Sub-flows accept input/output parameters: a better option

<evaluate result="conversationScope.itinerary"
	expression="checkinAgent.findItinerary(passengerInfo)"/>
	
View Variables
---------------
Declare using the view-state <var> tag
-Convenient way to allocate a view-scoped object
Created when entering the view-state
-May also be @Autowired with dependencies
Referenced by expressions
-Often used as the data model for a single view
-Often updated over a series of Ajax requests

Nota: Se definen dentro del tag <view-state>, y se puede
utilizar para el atributo: "model" de este mismo tag,
y ademas, puede ser utilizado como parametro a llamadas de metodos
utilizando el tag <evaluate>
<evaluate expression="checkinAgent.findItinerary(passengerInfo)"/>

IMAGEN: RequestScopeVsFlashScope.png
 
FlashScope
----------
Lasts for the entire flow
-But is cleared each time a view renders
Effective scope is:
-Transition from current view to end of "render of next view"
Used to pass data from one state to the next
-Especially request/view scoped data
-Very useful scope

Request Scope
-------------
Two requests per interaction
-First: transition from current state to on-entry of next state
-Second: From on-render of next state to end of render of same state
Typical Usage
-Data needs fetching every time state is redisplayed
--If data can be cached, make it view scoped
-Data needed to initialize next state, but not displayed by it
Generally not that useful (flash scope easier)

Examples
--------
Wherever a variable can be set – its scope can be defined
<set name="flashScope.accountNumber" value="requestParameters.accountNumber"/>
<set name="flashScope.statusMessage" value="'Booking confirmed'"/>
<set name="requestScope.hotelId" value="requestParameters.id"/>

Scope Implementation
--------------------
Conversation, Flow and View scope data are all stored in the user's HTTP session
-After the View has been presented
--The flow then suspends until next transition
-All variables should be Serializable
--Overhead if you store too much data

Flash scope also stored temporarily in session across redirect
-Same considerations: Serializable, overhead

Actions
=======
-Actions execute behavior at specific points within the flow
-Several points where actions can be executed
--on startup, before rendering, on transition, etc

Flow actions often act on Java objects
-Invoke Spring-managed services
-Assign variables

Writing an expression

evaluate
-Evaluate an expression
-Can prevent a transition

set
-Set the value of a variable
-Never prevent a transition, regardless of variable value

Evaluate Action
---------------
-Use <evaluate> to evaluate an expression
-Actions are expressed in EL
-Can use any object in flow context
--Resolve properties on beans in scope
--Invoke methods
-Can also assign result of evaluation
--Save result to a scope
--Optionally perform a result type conversion

<evaluate result="flowScope.itinerary"
	expression="checkinAgent.findItinerary(passengerInfo)" />

Spring EL Syntax
----------------
<variable>[.property]
-Variable resolved against current flow context
-Property can be JavaBeans property or method

Variable resolution "algorithm"
-Search reserved variables first
-Search web flow scopes second
>>request/flash/view/flow/conversation
-Search flow application context third
>>resolve Spring beans

flowScope.foo	[Resolve 'foo' in flow scope]
foo				[Search all scopes looking for 'foo']
foo.bar()		[Invoke method 'bar' on foo]
foo.bar(baz)	[Invoke method bar passing in variable 'baz']

Reserved SpEL Variables
-----------------------
conversationScope
flowScope
viewScope
requestScope
flashScope
flowExecutionUrl
flowRequestContext

requestParameters
currentEvent
currentUser
externalContext
messageContext
resourceBundle

NOTA: sessionScope NO EXISTE. Use externalContext.sessionMap

Reserved EL Variables in JSP
----------------------------
Only the following are valid in a JSP page
-Any variables in scope
-requestScope, viewScope , flashScope
-flowExecutionUrl = url of current page
-flowRequestContext = the RequestContext

This is in addition to usual variables
-sessionScope, pageScope, params, ...

For anything else, use flowRequestContext
-flowRequestContext.currentState.id

Examples
--------
<evaluate expression="checkinAgent.update(passengerInfo)" />

<evaluate expression="checkinAgent.findItinerary(passengerInfo)"
	result="flowScope.itinerary" />

<evaluate expression="bookingAgent.countMatches(searchCriteria)"
	result="flowScope.hotelsFound" result-type="long"/>
*El result-type puede ser un string o cualquier tipo primitivo, bigInteger, bigDecimal, 
or fully-qualified class name

Set Action
----------

Assign a new variable in a scope (Must specify a scope, no default)
<set name="flowScope.accountNumber"
	value="requestParameters.accountNumber"/>
	
Update the value of an existing variable
-Or one of its properties
-Scope optional: scope resolution algorithm used
<set name="searchCriteria.sortBy"
	value="requestParameters.sortBy"/>

Places to Invoke Actions From
-----------------------------
-When a flow starts/ends
<flow>
	<on-start>
		<evaluate expression="..."/>
	</on-start>
	
	<on-end>
		<evaluate expression="..."/>
	</on-end>
</flow>


-When a state is entered/exited and rendering/transition

<view-state>
	<on-entry>
		<evaluate expression="..." />
	</on-entry>
	
	<on-render>
		<evaluate expression="..." />
	</on-render>
	
	<transition>
		<evaluate expression="..." />
	</transition>
	
	<on-exit>
		<evaluate expression="..." />
	</on-exit>

</view-state>


Actions During Transitions
--------------------------
Run prior to the transition
Transition will only occur if <evaluate/> returns
-Boolean.TRUE or true
-One of these Strings: "success", "yes", "true"
-Any other type or null
Only one evaluate is allowed 
NOTA: intente colocar varios <evaluate> y lo permite (no se si sea por la ultima version)

-Recall: <set/> never prevents a transition, use as many as you want
<transition on="modify " to="searchForm " >
	<evaluate expression=" ... ">
</transition>

Actions Before Rendering
------------------------
<view-state id="enterPassengerInformation">
	<on-render>
		<evaluate expression="...">
	</on-render>
</view-state>

Executed again on every browser refresh
-contrast to on-entry

Form Handling Views
-------------------
Data binding and validation with Forms
-A common use for views

A view can be associated with a model object
-The form object in MVC

<view-state id="enterPassengerInformation"
	model="passengerInfo" />
	
The model object can be in different scopes

Submitting the Form
-------------------
"Automatic" data binding + validation

Can be suppressed

<view-state id="enterPassengerInformation" model="passengerInfo">
	<transition on="submit" to="reviewItinerary" />
	<transition on="cancel" to="end"
		bind="false" 
		validate="false"/>
</view-state>

Flow remains in same view on submit failure

Restricting Automatic Binding
-----------------------------
Not all fields should be bound to
-fields which are read but not written by the end-user
-application security can be compromised

Binder white-lists elements eligible for binding
<view-state id="enterDiningInformation" model="diningForm">
	<binder>
		<binding property="amount" required="true" />
		<binding property="creditCardNumber" required="true" />
		...
	</binder>
</view-state>


//XXX TODO: NO PUDE CON ESTA DIAPOSITIVA :(
Customizing Type Conversion
---------------------------
Spring 3 Formatters can also be used for Web Flow
-Same approach as in Spring MVC
Custom formatters defined for Spring MVC are not
automatically defined for Web Flow as well
-Must be explicitly associated using flow builder services
-Default formatters are present in both "out of the box"

<webflow:flow-builder-services
	id="flowBuilderServices" 
	conversion-service="converter"/>

<webflow:flow-registry 
	id="flowRegistry"
	flow-builder-services="flowBuilderServices">

Data Binding Error Messages
---------------------------
Web Flow uses a different strategy for generating
typeMismatch and required error codes
-The error code is appended to the end and not at the beginning

typeMismatch
amount.typeMismatch
diningForm.amount.typeMismatch
common.money.MonetaryAmount.typeMismatch

required
amount.required
diningForm.amount.required
common.money.MonetaryAmount.required

Customizing Data Binding Error Messages
---------------------------------------
To use same error code strategy in WebFlow as MVC,
add a DefaultMessageCodesResolver

<bean id="viewFactoryCreator" class="...MvcViewFactoryCreator">
	<property name="viewResolvers" ref="tilesViewResolver" />
	<property name="messageCodesResolver ref="mcr" />
</bean>

typeMismatch.amount.
typeMismatch.diningForm.amount
typeMismatch.common.money.MonetaryAmount

//XXX TODO HASTA ACA NO PUDE

Validation Options
------------------
JSR 303 validation support
-annotate the form object
-automatically used for validation
-but: you must enable this

Custom validators
-well-known method or class
-automatically invoked

Can use either, both or neither

JSR 303 Validation (Web Flow 2.3)
---------------------------------
Enable same validator as MVC
-via Web Flow builder services

<webflow:flow-builder-services
	id="flowBuilderServices" validator="validationService"/>
<bean id="validationService" class="org.springframework.
	validation.beanvalidation.LocalValidatorFactoryBean"/>

public class AccountSearchCriteria {
	@NotEmpty
	private String searchString = "";
	
	@Min(0) @Max(100)
	private int maximumResults = 10;
}

Validation In Code
------------------
Four Options
-Add a method with specific signature to Model Object (1)

-Create a class with a specific name
 >Add a method whose name relates to the view (2)
 >Define a validate() method taking the Model Object type (3)

-Write your own validator class (4)
 >Invoke a validation method in flow XML

e.g. Having this view
<view-state id="searchForm" model="accountSearchCriteria" >

1. Validation Via Model Object
------------------------------
Method "discovered" by convention
-validate[view-state-id](ValidationContext ctx)

public class AccountSearchCriteria {
	public void validateSearchForm (ValidationContext ctx) {...}
}

2. Custom Validation Class
--------------------------
Separate validator bean "discovered" by convention
-Bean name: [model-object-name]Validator
-Method name validate[view-name]

Looks for bean by name not type
@Component("accountSearchCriteriaValidator")
public class AccountSearchCriteriaValidator {
	public void validateSearchForm
	(AccountSearchCriteria target, ValidationContext ctx) {...}
}

3. Custom Validation Class, Any View
------------------------------------
Generic validator, independent of any view
-Bean name: [model-object-name]Validator
Method must be called validate
 -Called for any view where AccountSearchCriteria is the model object

@Component("accountSearchCriteriaValidator")
public class AccountSearchCriteriaValidator {
	public void validate(AccountSearchCriteria target, ValidationContext ctx) {...}
}

4. Manual Validation via <evaluate>
-----------------------------------
If you don’t like using our conventions

Validate using an <evaluate> action
If validator returns false, transition is prevented

<view-state id="enterBooking" model="booking">
	<transition on="submit" to="confirmBooking">
		<evaluate expression="bookingValidator.check(booking, messageContext)"/>
	</transition>
</view-state>

public class BookingValidator {
	public boolean check(Booking booking,MessageContext ctx) {...}
}

Registering Errors
------------------
Using an Errors object
-commonly used in Spring MVC

errors.rejectValue("creditCardNumber","creditCard.invalidNumber",
	"A credit card number must have 16 digits.");
	
or

Using a ValidationContext
addMessage(new MessageBuilder().error()
	.source("creditCardNumber")
	.code("creditCard.invalidNumber")
	.defaultText("A credit ... 16 digits.").build());	
	
Web Flow Action States
======================

Branching
---------
Flow navigation logic is often dynamic
-e.g. If <x> then go <y>, else go <z>

View States only go so far for these cases
-You can prevent the user from leaving a view because an action fails
-But you cannot easily change the target state to transition to based on some condition

"Action" and "Decision states" exist to implement dynamic navigation rules

Action State
------------

Allows you to transition to a state that executes one or more actions
-<evaluation/>, <set/>

The action's result is raised as an event
-<evaluation/> only
--<set/> always returns true

This event triggers a transition to another state
-Different events can be raised to trigger different transitions
 dynamically

Several result (return) types possible
-Always converted to a String

Options are:
>Booleans (always evaluate to “yes” or “no”)
--Will not match “true” or “false”

>Strings

>Enumerated types (converted to a String)

>org.springframework.webflow.execution.Event
-transition uses event's id string

>Any other value (including null) evaluates to “success”

Examples
--------
<action-state id="bookingFound">
	<evaluate expression="checkinService.bookingExists(paxInfo)"/>
	<transition on="no" to="enterPassengerIdentification"/>
	<transition on="yes" to="reviewItinerary"/>
</action-state>

<action-state id="bookingFound">
	<set name="flowScope.booking” value="checkinService.findBooking(paxInfo)”/>
	<evaluate expression="booking != null"/>
	<transition on="no" to="enterPassengerIdentification"/>
	<transition on="yes" to="reviewItinerary"/>
</action-state>


Transition Action Examples
--------------------------
A transition occurs if its <evaluate> succeeds
-Result of evaluation can be
 >Boolean: true
 >String: “yes”, “true”, “success”
 >Enumerated values converted to Strings
 >Any other object treated as “success”, so is null
 
<view-state id="enterPassengerIdentification" model="paxInfo">
	<transition on="submit" to="reviewItinerary">
		<evaluate expression="checkinService.bookingExists(paxInfo)"/>
	</transition>
</view-state>
 
Different Types of Actions
--------------------------
No Action
 >Invoke business services directly
 
POJO Action
 >A POJO invoked by the flow
 
Action
 >Implements webflow.action.Action (interface)

MultiAction
 >extends MultiAction, allows for multiple strongly typed
  actions to be grouped together

No Action
---------
-Transition on result of method call on a business-level service
-Methods can be injected with request context and/or flow variables

<action-state id="performBooking">
	<evaluate expression="bookingService.make(booking)"/>
	<transition on="success" to="bookingComplete"/>
</action-state>

@Service(“bookingService”)
public class BookingServiceImpl implements BookingService{
	public BookingConfirmation make(Booking booking) {
		BookingConfirmation confirmation;
		...
		return confirmation;
		//Remember, most return types evaluate to “success”
	}
}

POJO Action
-----------
A variation on what you've seen so far
-Transition on result of method call on a display-layer POJO
-Typically a web-flow object or a spring-bean

Methods
-Can have any sensible signature
 >Any variables in scope can be passed
 
-Can also be injected with request context
 >Hence context is managed explicitly by you
 
-Must return a String to transition on

<action-state id="performBooking">
	<evaluate expression="bookingAction.book(booking, flowRequestContext)"/>
	<transition on="success" to="bookingComplete"/>
</action-state>

@Component
public class BookingAction {
	public String book(Booking booking, RequestContext context){
		BookingConfirmation confirmation = bookingService.make(booking);
		...
		return "success";
	}
}

Plain Action
------------
Create a simple class for each action

Two ways to create
-implement Action interface
-Often easier to extend AbstractAction class

package org.springframework.webflow.execution;
public interface Action {
	public Event execute(RequestContext context) throws Exception;
}
//Context passed automatically by Spring

e.g.
<action-state id="performBooking">
	<evaluate expression="bookingAction"/>
	<transition on="success" to="bookingComplete"/>
</action-state>


@Component
public class BookingAction implements Action {

	//Context passed automatically by Spring
	public Event execute(RequestContext context) {
		Booking booking = (Booking) context.getFlowScope().get("booking");
		BookingConfirmation confirmation = bookingService.make(booking);
		...
		return new Event(this, "success" );
	}
}

MultiAction
-----------
Subclass MultiAction class
-Allows mutiple action methods on one class

-Methods must have the same signature
public Event methodName(RequestContext context) throws Exception

-Helper methods provided for returning Events
 >success(), error(), yes(), no()
 >result(), result(String), error(Exception)
 
 e.g.
<action-state id="performBooking">
	<evaluate expression="bookingAction.makeBooking"/>
	<transition on="success" to="bookingComplete"/>
</action-state>

@Component
public class BookingAction extends MultiAction {
	public Event makeBooking(RequestContext context) {
		Booking booking = (Booking) context.getFlowScope().get("booking");
		BookingConfirmation confirmation = bookingService.make(booking);
		...
		return success();
	}
}

When to use which action?
-------------------------
No Action
-Looks good on paper, allows a flow to invoke your business logic directly
-However, tighter coupling between your flow and your business logic can bloat your flow definiton

POJO Action
-Commonly used to glue your flow logic with your business layer in a decoupled way
-Allows for flexibility to encapsulate the handling of business-layer exceptions, for example
-Typically results in slightly more complex flow definitions

Plain Action
-Rarely used directly

Multi Action
-Commonly used to glue your flow logic with your business layer in a decoupled way
-Allows for flexibility to encapsulate the handling of business-layer exceptions, for example
-Typically result in slightly more complex Action code

Suggestion
-Use either POJO Action or MultiAction
-Weigh complexity of flow definition vs. complexity of Action

RequestContext
--------------
Passed to any of the action types
-Provides access to all data currently in scope
 >getFlowScope() - can read and write flow data
 
-Info about the flow itself
 >getActiveFlow(), getCurrentState(),getFlowExecuteURL()

-Access to the message-context
 >getMessageContext()
 
-Info about the calling context and how the flow was invoked
 >getExternalContext()
 
 
Decision State
--------------
Similar to an action state
-For explicit state transition control

Provides a convenient if/then syntax for evaluating a boolean expression
-Boolean return value determines next state to go to
-For more than one condition, use an action state

<decision-state id="isValidBooking">
	<if test="checkinService.bookingExists(passengerInfo)"
		then="reviewItinerary"
		else="enterPassengerIdentification"/>		
</decision-state>

Exception Handling
------------------
Actions often invoke services that may throw checked Business Exceptions

How should the flow handle these exceptions?
-(1)In the flow XML
-(2)Using a global exception handler
-(3)Using an Action class and returning an error event

***Option One
-Let the exception propagate
-Have the XML flow definition handle it in a transition via
on-exception "attribute"

<transition on-exception="accounts.NoSuchAccountException"
to="endCancel" />

***Option Two (Global Transitions)
Declare exception handling globally
-Place at end of flow

Exception can be thrown from any state in a flow
<flow>
	...
	<global-transitions>
		<transition on-exception="accounts.NoSuchAccountException" to="endCancel" />
	</global-transitions>
</flow>

***Option Three (Handle in Action Class)
-Using an ExceptionHandler is not clean (XML Bloat)
-Instead, catch exception in Action & return error event

public class BookingAction extends MultiAction {
	public Event makeBooking(RequestContext context) {
		try {
			Booking booking = ...
			return success();
		} catch (SomeException e) {
			return error(e); // Optionally pass exception
			//Available as $exception in event-context
		}
	}
}

Flow Contract
-------------
A flow is like any other method with an input-output contract
-Named parameters are passed in and out of flows
 >Passed as values in a Map
 
-Need a FlowHandler to create input and process output

<flow>
	<input name="accountNumber" required="true"/>
	...
	<end-state id="confirm">
		<output name="confirmationNumber" value="confirmation.id"/>
	</end-state>
</flow>


Flow Handler
------------
public interface FlowHandler {
	// What flow does this handler apply to?
	public String getFlowId();
	
	// Creates input map to pass to new flow instance
	public MutableAttributeMap<Object> createExecutionInputMap(HttpServletRequest request);
	
	// Return location of the resource to redirect to when flow ends
	// Use outcome.getOutput() to access <output> data
	public String handleExecutionOutcome(FlowExecutionOutcome outcome,
		HttpServletRequest request, HttpServletResponse response);
		
	// Handles a flow exception not handled by the Web Flow system.
	public String handleException(FlowException e, HttpServletRequest request, HttpServletResponse response);
}

***Implement to setup flow input data and to access data returned
***Easier to extend AbstractFlowHandler


Subflows
--------
A flow invoked from another flow
-Self contained execution
-Parent flow is suspended while subflow is executing

Has own scope
-Flow scope isolated to particular flow or subflow
-Conversation scope shared between parent flow and all subflows


Subflow State
-------------
-Subflow launched from special state in parent flow
-Transitions keyed from subflow's end-state id

<subflow-state id="beneficiaries" subflow="editBeneficiaries">
	<transition on="endCommit" to="confirm"/>
	<transition on="endCancel" to="edit"/>
</subflow-state>


Subflow Input/Output
--------------------
Pass data between calling flow and subflow

**calling flow
<subflow-state id="beneficiaries" subflow="editBeneficiaries">
	<input name="accountNumber" value="account.number"/>
	<output name="confirmationNumber" value="flowScope.confirmationNumber"/>
	...
</subflow-state>

**subflow “editBeneficiaries”
<flow ...>
	<input name="accountNumber" required="true"/>
	...
	<end-state id="endCommit">
		<output name="confirmationNumber" value="confirmation.id" />
	</end-state>
	
	<end-state id="endCancel"/>

</flow>

Mocking Subflows
----------------

**METHOD
public Flow createMockEditBeneficiariesSubflow() {
	
	Flow mockSubflow = new Flow("editBeneficiaries");
	
	//INPUT
	mockSubflow.setInputMapper(
		new Mapper() {
			public MappingResults map(Object source, Object target) {
				assertEquals(1L,((AttributeMap) source).get("accountNumber")); 		// test input mapping
				return null;
			}
		};
	);
	
	//OUTPUT
	mockSubflow.setOutputMapper(new DefaultMapper.addMapping(...) );
	
	// immediately return so the caller can respond
	//END-STATE
	new EndState(mockSubflow, "endCancel");

	return mockSubflow;
}

**Y PARA REGISTRARLO
getFlowDefinitionRegistry().registerFlowDefinition(
								createMockEditBeneficiariesSubflow() );
								
Flow Inheritance
----------------
-Share common states, actions across flows

-Support for multiple inheritance
 >More like composition than inheritance
 
-Merge (not override) differences between parent and child flow								

-Child flow and parent flow are both registered in the same FlowRegistry

Flow Level Inheritance	(HERENCIA DE FLOWS)
----------------------
Merges all elements of parent flow into child
-Parent's actions are executed first

<flow ... parent="parentFlowName">

Comma separated flow names for multiple inheritance
-Order has no effect on resulting flow

Abstract flows cannot be directly instantiated, only extended

<flow ... abstract="true">

State Level Inheritance (HERENCIA DE ESTADOS)
-----------------------
Only specified state's elements are merged

<view-state ... parent="parentFlowName#stateId">

Must specify flow name and state id
-flowId[#stateId]
-default stateId is current state's id
-Only single inheritance supported

Must be of the same state type
-view-state to view-state, end-state to end-state, ...

e.g. (1)
***common.xml
<flow abstract="true">
	<end-state id="endCancel" />
	<global-transitions>
		<transition on-exception="accounts.NoSuchAccountException“ to="endCancel" />
	</global-transitions>
</flow>

***child.xml
<flow parent="common">
	...
	<view-state id="confirm">
		<transition on="save" to="endComplete" />
	</view-state>
	
	<end-state id="endComplete" />
</flow>

DESPUES QUE SE APLICA LA HERENCIA, EL CHILD QUEDA ASI:

<flow>
	...
	<view-state id="confirm">
		<transition on="save" to="endComplete" />
	</view-state>
	
	<end-state id="endComplete" />
	
	<end-state id="endCancel" />
	
	<global-transitions>
		<transition on-exception="accounts.NoSuchAccountException“ to="endCancel" />
	</global-transitions>
</flow>


Execution Listeners
-------------------
Observe flow execution life-cycle events
-must implement FlowExecutionListener
-registered with the flow execution engine

<webflow:flow-executor id="flowExecutor" flow-registry="flowRegistry">
	<webflow:flow-execution-listeners>
		<webflow:listener ref="myFlowListener" />
	</webflow:flow-execution-listeners>
</webflow:flow-executor>


FlowExecutionListener
---------------------
Methods to respond to web-flow events:
-created, loaded, paused, resumed, saved, removed
-eventSignaled
-requestProcessed, requestSubmitted
-sessionStarting, sessionStarted, sessionEnded
-stateEntering, stateEntered

Several predefined
-Security, Persistence, Faces (JSF)
-Can write your own (for example: event tracing/logging)

Flow-Based Security
-------------------
Web Flow also integrates with Spring Security

These “resources” can be secured
-flows
-states
-transitions

How To Secure A Flow
--------------------
Standard Spring Security configuration
-secure the web-flow URLs
-orthogonal (independent) to Web Flow

A SecurityFlowExecutionListener declaration
-configured and added to the flowExecutor

Add <secured> elements to the flow definition


Flow Security Attributes
------------------------
***flow
<flow ...>
	<secured attributes="ROLE_USER" />
</flow>

***state
<flow ...>
	<view-state id="edit">
		<secured attributes="ROLE_USER" />
	</view-state>
</flow>

***transition
<flow ...>
	<view-state id="edit">
		<transition on="next" to="beneficiaries">
			<secured attributes="ROLE_USER" />
		</transition>
	</view-state>
</flow>



Configuring a Security Flow Execution Listener
----------------------------------------------
Flow <secured> element will be ignored without a
SecurityFlowExecutionListener in place

<bean id="securityFlowExecutionListener" 
	class="...webflow.security.SecurityFlowExecutionListener"/>
	
<webflow:flow-executor id="flowExecutor">
	<webflow:flow-execution-listeners>
		<webflow:listener ref="securityFlowExecutionListener"/>
	</webflow:flow-execution-listeners>
</webflow:flow-executor>


Non-Role Based Authorities
--------------------------
Application may choose to authorize on something other than roles
-Can override default AccessDecisionManager
-Set "accessDecisionManager" property on listener

<bean id="securityFlowExecutionListener”
	class="...webflow.security.SecurityFlowExecutionListener">
	
	<property name="accessDecisionManager" ref="myDecisionMgr" />
</bean>

Exception Handling
------------------
The SecurityFlowExecutionListener throws AccessDeniedException
-Bubbles up and is caught by a Spring Security servlet filter

Avoid catching/suppressing that exception
-If using SimpleMappingExceptionResolver, override
 the doResolveException method to rethrow the exception

Ignoring Exceptions in a Resolver
---------------------------------
public class SmartExceptionResolver extends SimpleMappingExceptionResolver {

	protected ModelAndView doResolveException(
						HttpServletRequest req, HttpServletResponse res,
						Object handler, Exception ex) {
						
		if (ex instanceof AccessDeniedException)
			throw (AccessDeniedException) ex;
			
		return super.doResolveException(req, res, handler, ex);
	}
}

Flow Execution Tuning
---------------------
Limit the number of flow executions and snapshots for a user session
-reduce memory overhead from “hog” users
-less likely to encounter an OutOfMemory exception

//Maximum 5 concurrent flow executions per user. 
//No more than 30 snapshots per execution.
<webflow:flow-execution-repository max-executions="5"
	max-execution-snapshots="30" />
	
Warning: going back beyond first snapshot:
Web Flow throws FlowExecution-RestorationFailureException

**Java Configuration
@Configuration
public class WebFlowConfig extends AbstractFlowConfiguration {
	@Bean
	public FlowExecutor flowExecutor() {
		return getFlowExecutorBuilder(flowRegistry())
				.setMaxFlowExecutions(5)
				.setMaxFlowExecutionSnapshots(30)
				.build();
	}
...

Embedded Flows
--------------
Every Web Flow transition involves a redirect

Not always desirable
-If using an AJAX-style partial page refresh
-Trying to make page modal
 >Stops user leaving flow with obsolete flow-data in Session
 
Embedded flows (WebFlow 2.3)
-Allow a transition with no redirect between different states
 >Page must dynamically refresh its contents

Initiated via parameter when flow started
-/flights/checkin?mode=embedded







SLIDE: 918 LAB

>>>TODO testear los ConversionService en WebFlow slide 874<<<

>>>INDAGAR LOS SIGUIENTES TAGS<<<
'{
"http://www.springframework.org/schema/webflow":action-state, 
"http://www.springframework.org/schema/webflow":decision-state, 
"http://www.springframework.org/schema/webflow":subflow-state, 
"http://www.springframework.org/schema/webflow":output, 
"http://www.springframework.org/schema/webflow":exception-handler, 
"http://www.springframework.org/schema/webflow":bean-import}'

[DOCUMENTATION]
http://docs.spring.io/spring-webflow/docs/current/reference/htmlsingle/
http://docs.spring.io/spring-webflow/docs/current/reference/html/defining-flows.html [DONE]
http://docs.spring.io/spring-webflow/docs/current/reference/html/el.html
https://www.adictosaltrabajo.com/tutoriales/primerospasos-spring-web-flow-2/